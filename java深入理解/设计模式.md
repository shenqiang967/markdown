# 设计模式

## 工厂模式

简单工厂模式：

```JAVA

public class FactoryTest {
    public static void main(String[] args) {
        Product product = new ApplicationCommon().getObject("1");
        product.product();

        ApplicationA applicationA = new ApplicationA();
        applicationA.createProduct().product();
    }
}
/**
 * 简单工厂模式
 * */

class SimpleProductFactory{
    public static Product createProduct(String type){
        switch (type){
            case "1":
                return new ProductA();
            case "2":
                return new ProductB();
            default:
                return new ProductC();
        }
    }
}

interface Product{
    void product();
}

class ProductA implements Product {

    @Override
    public void product() {
        System.out.println("producta is executed");
    }
}
class ProductB implements Product {

    @Override
    public void product() {
        System.out.println("productb is executed");
    }
}
class ProductC implements Product {

    @Override
    public void product() {
        System.out.println("productc is executed");
    }
}

class ApplicationCommon {
    Product getObject(String type){
        return SimpleProductFactory.createProduct(type);
    }
}

/**
 * 抽象工厂方法
 * 好处是符合开闭原则，有良好的扩展性
 * */

abstract class ConCreateProduct{
    abstract Product createProduct();
}

class ApplicationA extends ConCreateProduct{

    @Override
    Product createProduct() {
        return new ProductA();
    }
}
```

抽象工厂模式：

```JAVA

/**
 * 本次模拟对接黄山网约房数据的业务逻辑
 */
public class AbstractFactoryTest {
    public static void main(String[] args) {
        RoomOperate roomOperate = new RoomOperate();
        roomOperate.operate( "{\"id\":1,\"operation\":1}");
    }
}

/**
 * 业务逻辑：ROOM，ORDER，MERCHART，USER，ACTUALORDER
 * 本次提供五个接口，五个接口中分别提供了五张表业务数据的增删改
 * 为了扩展后期其他平台对接网约房特此需要不同的加密工具方法
 * 本次采用抽象工厂模式
 */

interface IAdd {
    /*新增*/
    void add(BaseAcceptData data);
}

interface IUpdate {
    /*修改*/
    void update(BaseAcceptData data);
}

interface IDelete {
    /*删除*/
    void delete(BaseAcceptData data);
}

interface ICurdUtils extends IAdd, IUpdate, IDelete {

}

/**
 * 统一基础父类,五个基础表的数据都应该继承自这个类
 */
@Data
class BaseAcceptData {
    /*接受数据的统一主键字段*/
    private Long id;
    /*接受数据的统一动作字段 1：新增，2：更新，3：删除*/
    private Integer operation;
}
@Data
class RoomData extends BaseAcceptData{
    private String name;
    private String address;
}

/**
 * 统一的加解密
 */
interface IEncrypt {
    String encrypt();

    String decrypt(String encryptString);
}

class MtAesProduct implements IEncrypt {
    public static MtAesProduct mtAesProduct = null;

    private MtAesProduct() {
    }

    ;

    @Override
    public String encrypt() {
        /*伪代码*/
        return null;
    }

    @Override
    public String decrypt(String encryptString) {
        /*伪代码*/
        return encryptString;
    }

    public static MtAesProduct getInstance() {
        if (!Optional.ofNullable(mtAesProduct).isPresent()) {
            /*锁住类实例*/
            synchronized (MtAesProduct.class) {
                /*双重判断防止其他线程同时进入第一层if，若不判断则会new出多个实例*/
                if (!Optional.ofNullable(mtAesProduct).isPresent()){
                    return new MtAesProduct();
                }
            }
        }
        return mtAesProduct;
    }

}
/**
 * 其中最初的意思 ABaseOperate只是一个操作的基类， 只放一个 operate 方法的，但是后期改动越来越多，自身懒惰直接就放在一起了
 * */
abstract class ABaseOperate implements ICurdUtils{
    /**将解密后的数据赋值给对应的业务类*/
    abstract BaseAcceptData mapToBaseAcceptData(JSONObject source);
    /**在基类数据赋值时的对应校验（非空，唯一，数据类型等），不同的业务实体，校验的逻辑不同，根据具体业务来实现该方法*/
    abstract Boolean verifyBaseAcceptData(BaseAcceptData baseAcceptData);
    /**对传输过来的数据进行解码以及调整*/
    void operate (String encryptString){
        IEncrypt encrypt = headersHandler();
        /*这边就暂时不传其他参数了，真正的代码都是带key以及偏转参数的*/
        String decryptString = encrypt.decrypt(encryptString);
        JSONObject jsonObject = (JSONObject) JSON.parse(decryptString);
        /*赋值的时候给出各种校验，这边不写了*/
        BaseAcceptData baseAcceptData = mapToBaseAcceptData(jsonObject);
        switch (baseAcceptData.getOperation()){
            case 1:
                add(baseAcceptData);
                break;
            case 2:
                update(baseAcceptData);
                break;
            default:
                delete(baseAcceptData);
                break;
        }

    }
    IEncrypt headersHandler(){
//        伪代码：校验clientId以及clientKey的正确性并返回相应的解码器
//        HttpServletRequest request
//        String clientId = request.getHeader("clientId");
//        switch (clientId){
//            case "":
//                return MtAesProduct.getInstance();
//            default:
//        }
        return MtAesProduct.getInstance();
    }
}
/**
 * 为什么子类要实现这五个接口
 * 因为每个表的业务实体都不一样，用一个统一的基类去代替某一个子类，到具体业务逻辑的时候再向下转型
 * */
class RoomOperate extends ABaseOperate{

    @Override
    public void add(BaseAcceptData data) {
        System.out.println("新增了："+data.toString());
    }

    @Override
    public void update(BaseAcceptData data) {
        System.out.println("修改了:"+data.toString());
    }

    @Override
    public void delete(BaseAcceptData data) {
        System.out.println("删除了:"+data.toString());
    }

    @Override
    BaseAcceptData mapToBaseAcceptData(JSONObject source) {
        RoomData room = new RoomData();
        room.setOperation(1);
        return room;
    }

    @Override
    Boolean verifyBaseAcceptData(BaseAcceptData baseAcceptData) {
        /*伪代码*/
        return true;
    }
}
```

